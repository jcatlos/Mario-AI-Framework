package levelGenerators.jcatlos

import java.io.File
import java.lang.Integer.max
import kotlin.random.Random
import kotlin.text.StringBuilder

/**
   * Data class allowing more elegant way of passing [Macro]-s from [RoomParser] to [RoomTemplate]
   *
   * Macros are executed at the time of a generation of an instance of [Room]
   *
   * @param string a string to be placed at the given position
   * @param prob [Int] probability (0-100) of the string appearing ath the given place
 */
data class MacroPair(var string: String, var prob: Int) {}

/**
 * macro to be executed at [Room] generation
 *
 * @param macros [ArrayList<MacroPair>] where each pair corresponds to one option to appear. Every option must be of the same length. The sum of their probabilities must not exceed 100. If the sum is below 100, the remaining probability is an implicit one - a sequence of '-'.
 * @property length the length of the string provided by the macro
 */

class Macro(var macros: ArrayList<MacroPair> = arrayListOf()){
    var length = 0
    init{
        for(macro in macros){
            length = max(length, macro.string.length)
        }
    }

    /**
     * Executes the [Macro] and returns the generated [String]
     *
     */

    fun execute(): String{
        //println("executing ${macros.toString()}")
        var rnd = Random.nextInt(100)
        var num: Int = macros[0].prob
        var index = 0
        while(rnd > num){
            println(index)
            rnd -= num
            index++
            if(index >= macros.size){
                return "-".repeat(length)
            }
            num = macros[index].prob
        }
        return macros[index].string.padEnd(macros[index].string.length, '-')
    }

    /**
     * Adds a [MacroPair] as an option to be generated by the [Macro]
     *
     * No checks are done, but the conditions must still be met after adding
     *
     * @param pair the [MacroPair] to be added
     */

    fun addPair(pair: MacroPair){
        length = max(length, pair.string.length)
        macros.add(pair)
    }
}


/**
 * Class used to store information about a Room prototype from a file
 *
 * - Prevents mutliple file reads at runtime
 * - generate() function generates a Room based on the prototype
 * - Allows querying the templates in SharedData on properties of the
 *
 * @param room [StringBuilder] containing the text representation of the room (macros are rep;aced by an adequate amount of '-')
 * @property width the width of the room
 * @param diff the arbitrary difficulty of the room
 * @param tags the *tags* for the room
 * @param macros the [Macro]-s specified in the room file
 * @param start [Coords] of the starting point
 * @param finish list of [Coords] of the exit points from the room
 */

class RoomTemplate(
        var room: Chunk,
        var diff: Int,
        var tags: ArrayList<String>,
        var macros: Map<Coords, Macro>,
        var start: Coords,
        var finish: ArrayList<Coords>)
{

    /*init{
        println("Room Template start = $start")
        for(f in finish){
            println("Room Template finish = $f")
        }
    }*/

    /**
     * Generates a [Room] based on this template
     */

    fun generate(): Room{
        //println
        //println("old room: ")
        //println(room.getAsStringBuilder());
        var newRoom = Chunk(room.getAsStringBuilder());
        //println(newRoom.toString())
        //println(macros.toString())
        var newDiff = diff

        /*var xCounter: Int = 0
        var yCounter:Int = 0
        while(xCounter < room.width && yCounter < room.height){
            var currentCoords = newRoom.currentPos()
            if(macros.contains(currentCoords)){
                // Since it was checked in the condition, should not be null (can use !!)
                var macroResult = macros[currentCoords]!!.execute()
                for(char in macroResult){
                    newRoom.append(char)
                }
            }
            else{
                var character = room.at(currentCoords)
                newRoom.append(character)
                if(character == '\n' || character =='\r'){
                    yCounter++
                    xCounter = 0
                }
                else{
                    xCounter++
                }
            }
        }*/


        for((coords, macro) in macros){
            var macroResult = macro.execute()
            for(i in 0 until macroResult.length){
                newRoom.content[coords.x + i][coords.y] = macroResult[i]
            }
            //newRoom.insert(coords.y * (room.width+1) + coords.x, macroResult)
            //newRoom[coords.y * width + coords.x] = macro.execute()
            //var enemyCount = macroResult.count { c -> c == 'k' || c == 'g'}
            //newDiff += enemyCount * 10
        }

        //println("After")
        //println(newRoom.getAsStringBuilder())
        //println("***")

        return Room(newRoom, newDiff, tags, start, finish)
    }
}


/*
interface RoomTemplateH1 : RoomTemplate {}

class ChallengeRoomTemplateH1(room: StringBuilder, diff: Int, macros: Map<Coords, Macro>) : RoomTemplateH1{
    override var room = room
    override var baseDifficulty = diff
    override var macros = macros

}

class BonusRoomTemplateH1(room: StringBuilder, diff: Int, macros: Map<Coords, Macro>) : RoomTemplateH1 {
    override var room = room
    override var baseDifficulty = diff
    override var macros = macros
}

class EmptyRoomTemplateH1(room: StringBuilder, diff: Int, macros: Map<Coords, Macro>) : RoomTemplateH1{
    override var room = room
    override var baseDifficulty = diff
    override var macros = macros

}



interface RoomTemplateH2 : RoomTemplate{}


class DivideHubTemplate(room: StringBuilder, diff: Int, macros: Map<Coords, Macro>) : RoomTemplateH2 {
    override var room = room
    override var baseDifficulty = diff
    override var macros = macros
}

class StartRoomTemplate(room: StringBuilder, diff: Int, macros: Map<Coords, Macro>) : RoomTemplateH2 {
    override var room = room
    override var baseDifficulty = diff
    override var macros = macros

}

class FinishRoomTemplate(room: StringBuilder, diff: Int, macros: Map<Coords, Macro>) : RoomTemplateH2 {
    override var room = room
    override var baseDifficulty = diff
    override var macros = macros
}

class ChallengeRoomTemplateH2(room: StringBuilder, diff: Int, macros: Map<Coords, Macro>) : RoomTemplateH2 {
    override var room = room
    override var baseDifficulty = diff
    override var macros = macros
}

class BonusRoomTemplateH2(room: StringBuilder, diff: Int, macros: Map<Coords, Macro>) : RoomTemplateH2 {
    override var room = room
    override var baseDifficulty = diff
    override var macros = macros
}

class EmptyRoomTemplateH2(room: StringBuilder, diff: Int, macros: Map<Coords, Macro>) : RoomTemplateH2{
    override var room = room
    override var baseDifficulty = diff
    override var macros = macros
}*/